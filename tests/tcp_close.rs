#![cfg(all(feature = "os-poll", feature = "tcp"))]

use mio::net::TcpListener;
use mio::{Events, Interest, Poll, Token};
use std::time::Duration;
mod util;
use util::init;

//
// There's a race condition if this test run in parallel with other tests.
// Right after fd is closed below, anyone can open a new file/socket and system
// might allocate the same fd for him. In such case test fails because it
// receives an event generated by another test running at the same time since
// it monitors fd owned by someone else.
//
// The test is alone in this source file on purpose to run single threaded and
// avoid above race condition.
//
#[test]
fn listen_then_close() {
    init();

    let mut poll = Poll::new().unwrap();
    let mut l = TcpListener::bind("127.0.0.1:0".parse().unwrap()).unwrap();

    poll.registry()
        .register(&mut l, Token(1), Interest::READABLE)
        .unwrap();
    drop(l);

    let mut events = Events::with_capacity(128);

    poll.poll(&mut events, Some(Duration::from_millis(100)))
        .unwrap();

    for event in &events {
        if event.token() == Token(1) {
            panic!("received ready() on a closed TcpListener")
        }
    }
}
